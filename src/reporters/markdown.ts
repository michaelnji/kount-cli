import fsp from 'node:fs/promises';
import path from 'node:path';
import type { ProjectStats } from '../plugins/types.js';

const KOUNT_HEADER = '<!-- KOUNT:START -->';
const KOUNT_FOOTER = '<!-- KOUNT:END -->';

/**
 * Generates a Markdown report string from ProjectStats.
 */
function generateMarkdownReport(stats: ProjectStats): string {
  const totalLines = stats.pluginResults.get('TotalLines')?.summaryValue ?? 0;
  const blankLines = stats.pluginResults.get('BlankLines')?.summaryValue ?? 0;
  const commentLines = stats.pluginResults.get('CommentLines')?.summaryValue ?? 0;
  const totalBytes = stats.pluginResults.get('FileSize')?.summaryValue ?? 0;
  const codeLines = totalLines - blankLines - commentLines;
  const codeRatio = totalLines > 0 ? ((codeLines / totalLines) * 100).toFixed(1) : '0.0';

  const formatSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  };

  const lines: string[] = [];
  lines.push(KOUNT_HEADER);
  lines.push('');
  lines.push('## Codebase Statistics');
  lines.push('');
  lines.push(`> Generated by [kount](https://github.com/kount) on ${stats.scannedAt.toLocaleDateString()}`);
  lines.push('');

  // Summary table
  lines.push('### Summary');
  lines.push('');
  lines.push('| Metric | Value |');
  lines.push('|--------|-------|');
  lines.push(`| Files | ${stats.totalFiles.toLocaleString()} |`);
  lines.push(`| Total Lines | ${totalLines.toLocaleString()} |`);
  lines.push(`| Code Lines | ${codeLines.toLocaleString()} |`);
  lines.push(`| Comment Lines | ${commentLines.toLocaleString()} |`);
  lines.push(`| Blank Lines | ${blankLines.toLocaleString()} |`);
  lines.push(`| Code Ratio | ${codeRatio}% |`);
  lines.push(`| Total Size | ${formatSize(totalBytes)} |`);
  lines.push('');

  // Language distribution (descending %)
  if (stats.languageDistribution.size > 0) {
    const sortedLangs = [...stats.languageDistribution.entries()]
      .sort((a, b) => b[1] - a[1]);

    lines.push('### Language Distribution');
    lines.push('');
    lines.push('| Language | Files | % |');
    lines.push('|----------|-------|---|');

    for (const [lang, count] of sortedLangs) {
      const pct = ((count / stats.totalFiles) * 100).toFixed(1);
      lines.push(`| ${lang} | ${count} | ${pct}% |`);
    }
    lines.push('');
  }

  // Top 10 largest files
  if (stats.largestFiles.length > 0) {
    lines.push('### Top 10 Largest Files');
    lines.push('');
    lines.push('| # | File | Size |');
    lines.push('|---|------|------|');

    for (let i = 0; i < stats.largestFiles.length; i++) {
      const file = stats.largestFiles[i];
      const relPath = path.relative(stats.rootDir, file.filePath);
      lines.push(`| ${i + 1} | \`${relPath}\` | ${formatSize(file.size)} |`);
    }
    lines.push('');
  }

  lines.push(KOUNT_FOOTER);
  return lines.join('\n');
}

/**
 * Writes the Markdown report to a file.
 * - By default, if the file exists, appends/replaces the KOUNT section.
 * - If `force` is true, overwrites the entire file.
 *
 * @param stats The aggregated project statistics.
 * @param outputPath The target markdown file path (defaults to README.md in rootDir).
 * @param force If true, overwrite the entire file instead of appending.
 */
export async function writeMarkdownReport(
  stats: ProjectStats,
  outputPath?: string,
  force: boolean = false
): Promise<string> {
  const targetPath = outputPath ?? path.join(stats.rootDir, 'README.md');
  const report = generateMarkdownReport(stats);

  if (force) {
    await fsp.writeFile(targetPath, report, 'utf8');
    return targetPath;
  }

  // Try to read existing file and replace KOUNT section, or append
  try {
    const existing = await fsp.readFile(targetPath, 'utf8');

    const startIdx = existing.indexOf(KOUNT_HEADER);
    const endIdx = existing.indexOf(KOUNT_FOOTER);

    if (startIdx !== -1 && endIdx !== -1) {
      // Replace existing KOUNT section
      const before = existing.substring(0, startIdx);
      const after = existing.substring(endIdx + KOUNT_FOOTER.length);
      await fsp.writeFile(targetPath, before + report + after, 'utf8');
    } else {
      // Append to the end
      await fsp.writeFile(targetPath, existing + '\n\n' + report, 'utf8');
    }
  } catch {
    // File doesn't exist â€” create new
    await fsp.writeFile(targetPath, report, 'utf8');
  }

  return targetPath;
}

export { generateMarkdownReport };
