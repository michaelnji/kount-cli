import * as fsp from 'node:fs/promises';
import path from 'node:path';
import type { ProjectStats } from '../plugins/types.js';

const KOUNT_HEADER = '<!-- KOUNT:START -->';
const KOUNT_FOOTER = '<!-- KOUNT:END -->';

/**
 * Generates a Markdown report string from ProjectStats.
 */
function generateMarkdownReport(stats: ProjectStats): string {
  const totalLines = stats.pluginResults.get('TotalLines')?.summaryValue ?? 0;
  const blankLines = stats.pluginResults.get('BlankLines')?.summaryValue ?? 0;
  const commentLines = stats.pluginResults.get('CommentLines')?.summaryValue ?? 0;
  const totalBytes = stats.pluginResults.get('FileSize')?.summaryValue ?? 0;
  const codeLines = totalLines - blankLines - commentLines;
  const codeRatio = totalLines > 0 ? ((codeLines / totalLines) * 100).toFixed(1) : '0.0';

  const formatSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  };

  const lines: string[] = [];
  lines.push(KOUNT_HEADER);
  lines.push('');
  lines.push('## Codebase Statistics');
  lines.push('');
  lines.push(`> Generated by [kount](https://github.com/kount) on ${stats.scannedAt.toLocaleDateString()}`);
  lines.push('');

  // Summary table
  lines.push('### Summary');
  lines.push('');
  lines.push('| Metric | Value |');
  lines.push('|--------|-------|');
  lines.push(`| Files | ${stats.totalFiles.toLocaleString()} |`);
  lines.push(`| Total Lines | ${totalLines.toLocaleString()} |`);
  lines.push(`| Code Lines | ${codeLines.toLocaleString()} |`);
  lines.push(`| Comment Lines | ${commentLines.toLocaleString()} |`);
  lines.push(`| Blank Lines | ${blankLines.toLocaleString()} |`);
  lines.push(`| Code Ratio | ${codeRatio}% |`);
  lines.push(`| Total Size | ${formatSize(totalBytes)} |`);
  lines.push('');

  // Language distribution (descending %)
  if (stats.languageDistribution.size > 0) {
    const sortedLangs = [...stats.languageDistribution.entries()]
      .sort((a, b) => b[1] - a[1]);

    lines.push('### Language Distribution');
    lines.push('');
    lines.push('| Language | Files | % |');
    lines.push('|----------|-------|---|');

    for (const [lang, count] of sortedLangs) {
      const pct = ((count / stats.totalFiles) * 100).toFixed(1);
      lines.push(`| ${lang} | ${count} | ${pct}% |`);
    }
    lines.push('');
  }

  // Top 10 largest files
  if (stats.largestFiles.length > 0) {
    lines.push('### Top 10 Largest Files');
    lines.push('');
    lines.push('| # | File | Size |');
    lines.push('|---|------|------|');

    for (let i = 0; i < stats.largestFiles.length; i++) {
      const file = stats.largestFiles[i];
      const relPath = path.relative(stats.rootDir, file.filePath);
      lines.push(`| ${i + 1} | \`${relPath}\` | ${formatSize(file.size)} |`);
    }
    lines.push('');
  }

  // Git Insights (only when git data is available)
  if (stats.gitInsights) {
    lines.push('### Git Insights');
    lines.push('');

    if (stats.gitInsights.diffBranch) {
      lines.push(`> Differential scan vs \`${stats.gitInsights.diffBranch}\``);
      lines.push('');
    }

    if (stats.gitInsights.topAuthors.length > 0) {
      lines.push('#### Top Contributors');
      lines.push('');
      lines.push('| # | Author | Commits |');
      lines.push('|---|--------|---------|');

      for (let i = 0; i < stats.gitInsights.topAuthors.length; i++) {
        const author = stats.gitInsights.topAuthors[i];
        lines.push(`| ${i + 1} | ${author.name} | ${author.commits} |`);
      }
      lines.push('');
    }

    if (stats.gitInsights.highChurnFiles.length > 0) {
      lines.push('#### High-Churn Files');
      lines.push('');
      lines.push('| # | File | Commits |');
      lines.push('|---|------|---------|');

      for (let i = 0; i < stats.gitInsights.highChurnFiles.length; i++) {
        const file = stats.gitInsights.highChurnFiles[i];
        const relPath = path.relative(stats.rootDir, file.filePath);
        lines.push(`| ${i + 1} | \`${relPath}\` | ${file.commits} |`);
      }
      lines.push('');
    }

    if (stats.gitInsights.staleFilesCount !== undefined || stats.gitInsights.knowledgeSilos) {
      lines.push('### Engineering Health');
      lines.push('');

      if (stats.gitInsights.staleFilesCount !== undefined) {
        lines.push(`- **Stale Files:** ${stats.gitInsights.staleFilesCount}`);
      }
      if (stats.gitInsights.knowledgeSilos) {
        lines.push(`- **Knowledge Silos:** ${stats.gitInsights.knowledgeSilos.length}`);
      }

      if (stats.gitInsights.suggestedReviewers && stats.gitInsights.suggestedReviewers.length > 0) {
        const reviewers = stats.gitInsights.suggestedReviewers.map(r => `${r.name} (${r.ownedLines} lines)`).join(', ');
        lines.push(`- **Suggested Reviewers:** ${reviewers}`);
      }
      lines.push('');

      if (stats.gitInsights.knowledgeSilos && stats.gitInsights.knowledgeSilos.length > 0) {
        lines.push('#### Knowledge Silos Details');
        lines.push('');
        lines.push('| File | Sole Author |');
        lines.push('|---|---|');
        for (const silo of stats.gitInsights.knowledgeSilos) {
          const relPath = path.relative(stats.rootDir, silo.filePath);
          lines.push(`| \`${relPath}\` | ${silo.author} |`);
        }
        lines.push('');
      }
    }
  }

  // Tech Debt (only when data is available)
  if (stats.highDebtFiles && stats.highDebtFiles.length > 0) {
    lines.push('### Tech Debt');
    lines.push('');
    lines.push(`**Total Score:** ${(stats.techDebtScore ?? 0).toLocaleString()}`);
    lines.push('');
    lines.push('| # | File | Score |');
    lines.push('|---|------|-------|');

    for (let i = 0; i < stats.highDebtFiles.length; i++) {
      const file = stats.highDebtFiles[i];
      const relPath = path.relative(stats.rootDir, file.filePath);
      lines.push(`| ${i + 1} | \`${relPath}\` | ${file.score.toLocaleString()} |`);
    }
    lines.push('');
  }

  // Top Dependencies
  if (stats.topDependencies && stats.topDependencies.length > 0) {
    lines.push('### Top Dependencies');
    lines.push('');
    lines.push('| # | Package | Imports |');
    lines.push('|---|---------|---------|');

    for (let i = 0; i < stats.topDependencies.length; i++) {
      const dep = stats.topDependencies[i];
      lines.push(`| ${i + 1} | \`${dep.name}\` | ${dep.count} |`);
    }
    lines.push('');
  }

  // Trends (only when previous run data is available)
  if (stats.trends) {
    const t = stats.trends;
    const fmt = (v: number) => (v > 0 ? `+${v.toLocaleString()}` : v.toLocaleString());
    lines.push('### Trends (vs Previous Scan)');
    lines.push('');
    lines.push('| Metric | Delta |');
    lines.push('|--------|-------|');
    lines.push(`| Files | ${fmt(t.fileDelta)} |`);
    lines.push(`| Lines | ${fmt(t.linesDelta)} |`);
    lines.push(`| Size | ${fmt(t.sizeDelta)} B |`);
    lines.push(`| Comment Ratio | ${fmt(t.commentRatioDelta)}% |`);
    lines.push(`| Debt Score | ${fmt(t.debtDelta)} |`);
    lines.push('');
  }

  lines.push(KOUNT_FOOTER);
  return lines.join('\n');
}

/**
 * Writes the Markdown report to a file.
 * - By default, if the file exists, appends/replaces the KOUNT section.
 * - If `force` is true, overwrites the entire file.
 *
 * @param stats The aggregated project statistics.
 * @param outputPath The target markdown file path (defaults to README.md in rootDir).
 * @param force If true, overwrite the entire file instead of appending.
 */
export async function writeMarkdownReport(
  stats: ProjectStats,
  outputPath?: string,
  force: boolean = false
): Promise<string> {
  const targetPath = outputPath ?? path.join(stats.rootDir, 'README.md');
  const report = generateMarkdownReport(stats);

  if (force) {
    await fsp.writeFile(targetPath, report, 'utf8');
    return targetPath;
  }

  // Try to read existing file and replace KOUNT section, or append
  try {
    const existing = await fsp.readFile(targetPath, 'utf8');

    const startIdx = existing.indexOf(KOUNT_HEADER);
    const endIdx = existing.indexOf(KOUNT_FOOTER);

    if (startIdx !== -1 && endIdx !== -1) {
      // Replace existing KOUNT section
      const before = existing.substring(0, startIdx);
      const after = existing.substring(endIdx + KOUNT_FOOTER.length);
      await fsp.writeFile(targetPath, before + report + after, 'utf8');
    } else {
      // Append to the end
      await fsp.writeFile(targetPath, existing + '\n\n' + report, 'utf8');
    }
  } catch {
    // File doesn't exist â€” create new
    await fsp.writeFile(targetPath, report, 'utf8');
  }

  return targetPath;
}

export { generateMarkdownReport };
